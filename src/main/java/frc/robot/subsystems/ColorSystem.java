// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import com.revrobotics.ColorSensorV3;
import com.revrobotics.ColorSensorV3.RawColor;

/**
 *
 */
public class ColorSystem extends SubsystemBase {

    private final ColorSensorV3 colorSensor = new ColorSensorV3(Constants.COLORSENSOR_I2C);

    private Color prevColor;
    private String prevColorName;
    private Color currentColor;
    private String currentColorName;
    private int consistentCount;
    private int inconsistentCount;
    private double th =0.1;


    public ColorSystem() {      
        SmartDashboard.putNumber("Color thresh hold", th);
    }

    public String getavrColor(int amt){
        float[] resultsR = new float[amt];
        float[] resultsG = new float[amt];
        float[] resultsB = new float[amt];

        float avrR =0;
        float avrG =0;
        float avrB =0;

        float avrDevR =0;
        float avrDevG =0;
        float avrDevB =0;

        for(int i=0; i<amt; i++){
            resultsR[i] = (float)getColor().red;
            resultsG[i] = (float)getColor().green;
            resultsB[i] = (float)getColor().blue;
            avrR+=resultsR[i];
            avrG+=resultsG[i];
            avrB+=resultsB[i];
        }
        avrR/=amt;
        avrG/=amt;
        avrB/=amt;

        for(int i=0; i<amt; i++){
            resultsR[i] = Math.abs(avrR - resultsR[i]);
            resultsG[i] = Math.abs(avrG - resultsG[i]);                
            resultsB[i] = Math.abs(avrB - resultsB[i]);
            avrDevR +=resultsR[i];
            avrDevG +=resultsG[i];
            avrDevB +=resultsB[i];
        }
        
        avrDevR/=amt;
        avrDevG/=amt;
        avrDevB/=amt;

        return "R:"+avrR+" d "+avrDevR +" G:"+avrG+" d "+avrDevG+" B:"+avrB+" d "+avrDevB;
    }

    public String getColorName(){
        th = SmartDashboard.getNumber("Color thresh hold", th);

        prevColorName = currentColorName;
        getColor();

        double r = currentColor.red;
        double g = currentColor.green;
        double b = currentColor.blue;

        if(Math.abs(0.13489306 - r) <=th && Math.abs(0.43538037- g) <=th && Math.abs(0.42972437 -b) <=th)
            currentColorName = "Blue";
        else if(Math.abs(0.17530347 - r) <=th && Math.abs(0.5667771 - g) <=th && Math.abs(0.25793532 -b) <=th)
            currentColorName = "Green";
        else if(Math.abs(0.48934227 - r) <=th && Math.abs(0.36309862 - g) <=th && Math.abs(0.14753516 -b) <=th)
            currentColorName = "Red";
        else if(Math.abs(0.31467456 - r) <=th && Math.abs(0.5550923 - g) <=th && Math.abs(0.13020141 -b) <=th)
            currentColorName = "Yellow";
        else
            currentColorName = "not found";
        return currentColorName;
    }

    public Color getColor() {
        prevColor = currentColor;
        currentColor = colorSensor.getColor();

        return currentColor;
    }

    public double getConsistency() {
        if(consistentCount + inconsistentCount == 0) {
            return 1.0;
        } else {
            return (double)consistentCount / (double)(consistentCount + inconsistentCount);
        }
    }

    public double getInfraRed() {
        return colorSensor.getIR();
    }

    public String getStringRGB() {
        return  colorSensor.getRed() + "," + colorSensor.getGreen() + "," + colorSensor.getBlue();
    }

    @Override
    public void periodic() {
        currentColor = colorSensor.getColor();
    }
}

